STATA16 code: 

use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/analysis/data/bp_med_log_v2.dta", clear

. distinct maskid 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |     193440       9344

* the total cohort has 9361 but the medication list here is only 9344 unique inidividuals. 
* the below 17 subjects are not in the bp_med_log_v2

MASKID
S00458
S01702
S13634
S13925
S16204
S19984
S24821
S31032
S46995
S57170
S67726
S69263
S75515
S78809
S86180
S94462
S97679



* drop duplicated 
sort maskid formdays
quietly by maskid formdays:  gen dup = cond(_N==1,0,_n)
tab dup
drop if dup == 2 
drop if dup == 3

Output:

          . tab dup
          
                  dup |      Freq.     Percent        Cum.
          ------------+-----------------------------------
                    0 |    193,129       99.84       99.84
                    1 |        154        0.08       99.92
                    2 |        154        0.08      100.00
                    3 |          3        0.00      100.00
          ------------+-----------------------------------
                Total |    193,440      100.00
          
          . drop if dup == 2 
          (154 observations deleted)
          
          . drop if dup == 3
          (3 observations deleted)


* Will merge with BP data now- I have tried to merge it later on but ran into issues where the maskid has only 
BP data without meds data presumably the maskid had the observations removed from some of the filters


. merge m:m maskid formdays using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (fr
> om Maria)/analysis/data/allbp_intensive+standard.dta"
(note: variable visitorder was byte, now int to accommodate using data's values)
    Result                           # of obs.
    -----------------------------------------
    not matched                        13,328
        from master                    10,457  (_merge==1)
        from using                      2,871  (_merge==2)

    matched                           182,889  (_merge==3)
    -----------------------------------------

. distinct maskid 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |     196217       9347


* Drop the CLOSEOUT visit while retaining all other observations for that maskid

. drop if visitcode == "CLO"
(7,980 observations deleted)

. distinct maskid 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |     188237       9347


. distinct maskid if _merge ==3

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |     175386       9344




* Sort the data by maskid and formdays
sort maskid formdays

* Generate the thiazide column, thiazide use ==1 

gen MRA = 0
forvalues i = 1/10 {
    replace MRA = 1 if (strpos(lower(medname`i'), "spir") > 0 |(strpos(lower(medname`i'), "actone") > 0 | strpos(lower(medname`i'), "inspra") > 0 | strpos(lower(medname`i'), "eple") > 0 | strpos(lower(medname`i'), "aldac") > 0)
}





Output: 
. distinct maskid if MRA ==1 


		

* Now remove on MRA at baseline

* Generate a flag for each medname column for MRA 
forvalues i = 1/10 {
    gen flag_mra`i' = strpos(lower(medname`i'), "spir") > 0 |(strpos(lower(medname`i'), "actone") > 0 | strpos(lower(medname`i'), "eple") > 0 | strpos(lower(medname`i'), "aldac") > 0 | strpos(lower(medname`i'), "inspra") > 0
}

* Create an indicator for any MRA use
gen any_mra = (flag_mra1 + flag_mra2 + flag_mra3 + flag_mra4 + flag_mra5 + flag_mra6 + flag_mra7 + flag_mra8 + flag_mra9 + flag_mra10) > 0

* Identify the first occurrence of MRA for each maskid
by maskid (formdays): gen first_mra_occurrence = any_mra == 1 & sum(any_mra) == 1

* explanation: sum(any_mra) is a running sum of the any_mra variable within each maskid group.
It equals 1 only for the first occurrence of a mra within each group. 
For each maskid, the function goes through the rows in order of formdays.
The first time it encounters a row where any_mra is 1, both conditions are true, so first_mra_occurrence is set to 1 for that row.
For any subsequent rows where any_mra is 1, the second condition (sum(any_mra) == 1) will be false, so first_mra_occurrence will be 0. This ensures that first_mra_occurrence is 1 only for the first occurrence of a mra medication for each patient, regardless of which row it appears in.


* Record the formdays and daysstart of the first MRA occurrence
gen first_mra_formdays = formdays if first_mra_occurrence == 1
by maskid: egen first_mra_formdays_filled = min(first_mra_formdays)


* explanation: Since we only filled in first_mra_formdays for the first occurrence, 
this minimum will be the formdays of the first mra occurrence. This function allows us to know when mra (in regards of formdays) was first started for a patient, regardless of which row we're looking at for that patient.

* Generate a column to store the daystart for MRA medications
sort maskid formdays
gen mra_daystart = .
forvalues i = 1/10 {
    replace mra_daystart = daysstart`i' if (strpos(lower(medname`i'), "spir") > 0 | strpos(lower(medname`i'), "eple") > 0 | strpos(lower(medname`i'), "aldac") > 0 | (strpos(lower(medname`i'), "actone") > 0 |(lower(medname`i'), "inspra") > 0)
}

gen first_mra_daysstart = .
forvalues j = 1/10 {
    replace first_mra_daysstart = daysstart`j' if first_mra_occurrence == 1 & flag_mra`j' == 1
}
by maskid: egen first_mra_daysstart_filled = min(first_mra_daysstart)

* Keep the 1st observation of MRA being started 
sort maskid formdays
bys maskid: egen min_mra_daystart = min(first_mra_daysstart)


* explanation: this is to capture the correct daysstart for the first mra occurrence, which could be in any of the 10 medication columns. Repeat this value for every row of each patient, which is useful for subsequent analyses or when checking for changes in medication timing.


* Remove patients who are on MRA at baseline
distinct maskid if mra == 1 & min_mra_daystart < 0
distinct maskid if mra == 1 & min_mra_daystart >= 0

* Generate a flag variable to identify observations with min_mra_daystart < 0
gen flag = (min_mra_daystart < 0)

* Create a variable that is 1 if any observation for a maskid has flag = 1
bysort maskid: egen maskid_flag = max(flag)

* Keep only observations where maskid_flag is 0 (i.e., remove all observations for maskids with min_mra_daystart < 0)
keep if maskid_flag == 0

* Clean up
drop flag maskid_flag



* Now after removing those on MRA at baseline, work on removing those on MRA combo meds


// Define the list of medication names to search for
// Create a local macro with the list of medications
local medlist `""spironolactone hct2" "spironolactone hctz" "spironolactone hydrochlorot" "spironolactone hydrochlorothiazide" "spironolactone-hctz" "spironolactone/HCTZ" "spironalactone/htctz" "spironactone-hctz" "Spironolactone-HCTZ" "HCTZ-Aldactone""'

* Generate a flag variable to identify observations with specified medications
gen flag = 0
forvalues i = 1/10 {
    foreach med of local medlist {
        replace flag = 1 if medname`i' == "`med'"
    }
}

* Create a variable that is 1 if any observation for a maskid has flag = 1
bysort maskid: egen maskid_flag = max(flag)

* Keep only observations where maskid_flag is 0 (i.e., remove all observations for maskids with flagged medications)
keep if maskid_flag == 0

* Clean up
drop flag maskid_flag




Output: 





* Generate a variable to count occurrences
gen mra_daystart_same_count = 0

* Loop through daysstart1 to daysstart10
forvalues i = 1/10 {
    replace mra_daystart_same_count = mra_daystart_same_count + 1 if daysstart`i' == mra_daystart & mra_daystart != .
}

* Generate indicator for multiple occurrences
gen multiple_same_daystart = (mra_daystart_same_count > 1) if mra_daystart != .

* Optional: Label the new variable
label variable multiple_same_daystart "More than one occurrence of daystart thats identical to mra_daystart in daysstart1-10"

* Now remove anyone who started MRA the same day with other meds
* Generate a flag variable to identify observations with multiple_same_daystart == 1
gen flag = (multiple_same_daystart == 1)

* Create a variable that is 1 if any observation for a maskid has flag = 1
bysort maskid: egen maskid_flag = max(flag)

* Keep only observations where maskid_flag is 0 (i.e., remove all observations for maskids with multiple_same_daystart == 1)
keep if maskid_flag == 0

* Clean up
drop flag maskid_flag




Output: 

			



* generate a cumulative count of how many times mra treatment starts for each patient
* counts the number of times mra switches from 0 to 1 within each maskid group
* mra_occurrence will be a cumulative count of the occurrences where:
    mra  changes from 0 to 1, or
    mra  is 1 at the start for the maskid, or formdays is 0 and mra is 1. (because there is no prior to compare if started on formdays 0)
    Because mra use at baseline is already removed, if mra use daystart = formdays 0 

sort maskid formdays
by maskid: gen mra_occurrence = sum(mra == 1 & (mra[_n-1] == 0 | _n == 1 | formdays == 0))

* keep only the first occurrence
drop if mra_occurrence > 1 & mra_occurrence !=.
			
			
* To know the previous visit before MRA turns 1
gen prior_onMRA = .
by maskid: replace prior_onMRA = formdays[_n-1] if mra == 1 & (mra[_n-1] == 0 | _n == 1) & mra_occurrence == 1

* This subsequent code ensures that only the 1st occurrence is used
replace prior_onMRA = . if mra_occurrence >= 2 & prior_onMRA != .

* Sort data by maskid and formdays
sort maskid formdays  

* Generate and fill up the entire column for each MRA occurrence
* Generate variables for the first and second occurrences of MRA
by maskid: gen first_onMRA = formdays if mra == 1 & sum(mra) == 1
by maskid: gen second_onMRA = formdays if mra == 1 & sum(mra) == 2

* Carry forward non-missing values in the column 'prior_onMRA'
bysort maskid (formdays): gen prior_onMRA_filled = prior_onMRA if prior_onMRA != .
bysort maskid (formdays): replace prior_onMRA_filled = prior_onMRA_filled[_n-1] if missing(prior_onMRA_filled)

* Include the first row as well
by maskid: replace prior_onMRA = prior_onMRA[_n+1] if missing(prior_onMRA) & !missing(prior_onMRA[_n+1])

* Sort data again by maskid and formdays
sort maskid formdays

* Fill in the first and second occurrences of MRA
by maskid: egen first_onMRA_filled = max(first_onMRA)
by maskid: egen second_onMRA_filled = max(second_onMRA)

* Generate and fill in the third and fourth occurrences of MRA
by maskid: gen third_onMRA = formdays if mra == 1 & sum(mra) == 3
by maskid: egen third_onMRA_filled = max(third_onMRA)
by maskid: gen fourth_onMRA = formdays if mra == 1 & sum(mra) == 4
by maskid: egen fourth_onMRA_filled = max(fourth_onMRA)



* medication list
sort maskid formdays
gen med_oxin = 0
gen med_triam = 0
gen med_olol = 0
gen med_ipine_azem = 0
gen med_thia_chlo_hct = 0
gen med_fur_bum_tors = 0
gen med_hydral_azine = 0
gen med_pril_artan = 0
gen med_idine_clon = 0
gen med_minoxi = 0 
gen med_guanfacine = 0 

* Check each medname variable for the specified patterns
forvalues i = 1/10 {
    replace med_oxin = 1 if regexm(lower(medname`i'), "(cardu|doxa|osin|oxin|hytrin|tera|tamsu|alfu)")
	replace med_triam = 0.0005 if regexm(lower(medname`i'), "(triam|amil)")
    replace med_olol = 2 if regexm(lower(medname`i'), "(olol|metop|coreg|carv|lopre|topr|propa|nebi|nado|atenelol)")
    replace med_ipine_azem = 5 if regexm(lower(medname`i'), "(ipine|azem|norv|vera|nife|proca|nicar|nefe|caduet)")
	replace med_minoxi = 10000 if regexm(lower(medname`i'), "(mino|xidil)")
	replace med_guanfacine = 0.01 if regexm(lower(medname`i'), "(guan)")
    replace med_thia_chlo_hct = 9 if regexm(lower(medname`i'), "(thia|chlo|chlorth|hyrdo|thiaz|azide|hyzaar|indap|metola|diurel|hctz|hygro|edarbyclor)")
    replace med_fur_bum_tors = 13 if regexm(lower(medname`i'), "(fur|bum|tors|inda|etha|demadex|lasix)")
    replace med_hydral_azine = 0.5 if regexm(lower(medname`i'), "(hydral|azine)")
    replace med_pril_artan = 1000 if regexm(lower(medname`i'), "(pril|artan|benic|vals|olme|edarbi|diovan|azil|trando|micardis|atacand)")
    replace med_idine_clon = 100 if regexm(lower(medname`i'), "(idine|clon|cata)")
}
* Sum all medication categories into a single variable
gen med_category = med_oxin + med_olol + med_ipine_azem + med_thia_chlo_hct + med_fur_bum_tors + med_hydral_azine + med_pril_artan + med_idine_clon + med_minoxi + med_triam + med_guanfacine 


* Label the new variable
label variable med_category "Sum of medication categories"

*this works for combination meds as well- for example, atenolol, amlodipine/benazapril, will sum up to 1007 ( 1000 + 5 + 2)

* Label the new variable
label variable med_category "Sum of medication categories"

* Clean up intermediate variables OR keep them for later 
drop med_oxin med_olol med_ipine_azem med_mra med_fur_bum_tors med_hydral_azine med_pril_artan med_idine_clon med_minoxi  med_triam med_guanfacine 


sort maskid formdays 
 
* Get med_category for first and second MRA visits
by maskid: gen prior_med_category = med_category if formdays == prior_onMRA

* Because prior_onMRA is one row below
by maskid: replace prior_med_category = med_category if formdays == prior_onMRA_filled

* Generate column to store "med_category" according to visits
by maskid: gen first_med_category = med_category if formdays == first_onMRA
by maskid: gen second_med_category = med_category if formdays == second_onMRA
by maskid: gen third_med_category = med_category if formdays == third_onMRA
by maskid: gen fourth_med_category = med_category if formdays == fourth_onMRA

* Fill these values for all rows within each maskid
by maskid: egen prior_med_category_filled = max(prior_med_category)
by maskid: egen first_med_category_filled = max(first_med_category)
by maskid: egen second_med_category_filled = max(second_med_category)
by maskid: egen third_med_category_filled = max(third_med_category)
by maskid: egen fourth_med_category_filled = max(fourth_med_category)

* Generate the difference in med_category between first and second visit - they should be equal 
gen med_category_diff_2_1 = second_med_category_filled - first_med_category_filled
gen med_category_diff_3_1 = third_med_category_filled - first_med_category_filled
gen med_category_diff_3_2 = third_med_category_filled - second_med_category_filled
gen med_category_diff_prior_1 = prior_med_category_filled - first_med_category_filled 
 
* Flag if med_category is unequal between visits
gen med_category_prior_1_unequal = (med_category_diff_prior_1 != 0 & med_category_diff_prior_1 !=.)
gen med_category_2_1_unequal = (med_category_diff_2_1 != 0 & med_category_diff_2_1 !=.)
gen med_category_3_1_unequal = (med_category_diff_3_1 != 0 & med_category_diff_3_1 !=. )
gen med_category_3_2_unequal = (med_category_diff_3_2 != 0 & med_category_diff_3_2 !=. ) 


* Label the new variables
label variable med_category_diff_2_1 "Difference in med_category between 1st and 2nd MRA visits"
label variable med_category_2_1_unequal "Flag: 1 if med_category unequal between 1st and 2nd MRA visits"

* now with the meds and visits sorted, remove if the med_category is different from the visit prior to MRA and on MRA startday

* Generate a flag variable to identify observations with multiple_same_daystart == 1
gen flag = (med_category_prior_1_unequal == 1)

* Create a variable that is 1 if any observation for a maskid has flag = 1
bysort maskid: egen maskid_flag = max(flag)

* Keep only observations where maskid_flag is 0 (i.e., remove all observations for maskids with multiple_same_daystart == 1)
keep if maskid_flag == 0

* Clean up
drop flag maskid_flag


2156 --> 2056 


Output: 




* explanation: the 2056 is from the criteria that no other meds share the SAME start day w thiazide. It does not exclude the meds that 
was started a couple of days before or after thiazide was started. The med_category list will reflect the changes of medications across visits, 
so it is a more robust way to ensure no other meds were started other than a thiazide. 

* Fill up the BP columns
* Generate variables for SBP at the time of MRA occurrences
by maskid: gen first_SBP = seatsys if formdays == first_onMRA_filled
by maskid: egen first_SBP_filled = max(first_SBP)
by maskid: gen second_SBP = seatsys if formdays == second_onMRA_filled
by maskid: egen second_SBP_filled = max(second_SBP)
by maskid: gen third_SBP = seatsys if formdays == third_onMRA_filled
by maskid: egen third_SBP_filled = max(third_SBP)
by maskid: gen fourth_SBP = seatsys if formdays == fourth_onMRA_filled
by maskid: egen fourth_SBP_filled = max(fourth_SBP)



* Find out who has missing SBP at baseline

gen have_SBP_baseline = .

Output: 

. replace have_SBP_baseline = 1 if first_SBP_filled !=.




* out of the 2056, 2010 has BP recorded for baseline 


* try this: 
sort maskid formdays 
by maskid: gen prior_SBP = seatsys[_n-1] if missing(seatsys) & !missing(seatsys[_n-1])
by maskid: replace prior_SBP = prior_SBP[_n-1] if missing(prior_SBP) & !missing(prior_SBP[_n-1])


* Calculate the Difference Between the Visit When MRA is Started and the Prior MRA Visit:

by maskid: egen mra_daystart_first = min(mra_daystart)
gen visit_diff_prior_MRA = mra_daystart_first - prior_onMRA_filled 
gen visit_diff_prior_and1_eligible = visit_diff_prior_MRA < 60 if !missing(visit_diff_prior_MRA)
gen eligible_missing_first_SBP = (visit_diff_prior_and1_eligible == 1 & med_category_prior_1_unequal == 0)
gen new_first_sbp = first_SBP_filled  
replace new_first_sbp = prior_SBP if missing(first_SBP_filled) & eligible_missing_first_SBP == 1

* Multiple visits may occur within 60 days before MRA initiation. The above code only considers the most recent visit.
* To account for all prior visits within 60 days and with unchanged medication lists (except for the addition of MRA), use Python to loop through these visits.


* If I were to use Python for this filters, I can actually not perform this part above

Output: 
. distinct maskid if new_first_sbp !=. 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |      35300       2051




* save as masterdata 
save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_mra_9.3.dta"

* Generate a subdata for calculation of average BP pre-MRA initiation 
use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_mra_9.3.dta"
sort maskid formdays

gen day_diff_pre = min_mra_daystart - formdays

* The mra initiation date should be greater than the visit date (FORMDAYS) because I want to obtain blood pressure (BP) values from visits prior to the initiation of mra.
For some participants, the date when mra was first recorded in the dataset (FORMDAYS) did not match the actual start date of the medication. It appears that these medications were initiated between visits.




gen day_diff_pre_2 = first_mra_formdays_filled - formdays
gen diff = day_diff_pre - day_diff_pre_2 

gen differentformdaysstartday = 1 if day_diff_pre != day_diff_pre_2 
distinct maskid if differentformdaysstartday == 1 
			
summarize diff, detail
			
			                          

* the histogram showed mostly in the range of plus minus 10-20. 

* therefore, I will use "first_mra_daystart" or "min_mra_daystart" over "first_mra_formdays" 

drop if day_diff_pre < 0 & day_diff_pre !=.

* Limit the prior visit to within 60 days
drop if day_diff_pre > 60 & day_diff_pre !=.

* Instead of sorting by formdays
* Sort by day_diff_pre so the first observation of the med_category, which is the day mra is started,
* can be used as a reference for prior visit med_category

sort maskid day_diff_pre
by maskid: gen consistent_med = (med_category == med_category[1])


* after I removed the day_diff_pre of >60 and <0, the diff is less skewed- looks like the outliers are gone now: 





* Browse data to export to Excel as CSV file
browse maskid formdays seatsys new_first_sbp day_diff_pre consistent_med min_mra_daystart

export delimited maskid formdays seatsys new_first_sbp day_diff_pre consistent_med min_mra_daystart using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/export_preMRA_bp_to_python_9.3", replace


save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/subset_masterdata_mra_9.3_for_preMRA_SBP_python.dta", replace


* enter Python 
import numpy as np
import pandas as pd

def calculate_bp_pre_mra(df):
    # Sort the dataframe by maskid and day_diff_pre in descending order
    df = df.sort_values(['maskid', 'day_diff_pre'], ascending=[True, False])

    # Initialize columns for bp_pre_MRA visits
    max_visits = 10  # Adjust this number based on your data
    for i in range(1, max_visits + 1):
        df[f'bp_pre_MRA_visit_{i}'] = np.nan

    # Function to process each patient
    def process_patient(group):
        visit_count = 0
        record_seatsys = False
        day_diff_pre_values = []  # List to store day_diff_pre values for valid visits

        for idx, row in group.iterrows():
            if 0 <= row['day_diff_pre'] <= 60:
                if row['consistent_med'] == 1:
                    if not pd.isna(row['seatsys']):
                        visit_count += 1
                        group.loc[idx, f'bp_pre_MRA_visit_{visit_count}'] = row['seatsys']
                        day_diff_pre_values.append(row['day_diff_pre'])
                        record_seatsys = True
                elif row['consistent_med'] == 0:
                    # Reset when consistent_med turns 0
                    record_seatsys = False
                    visit_count = 0
            if row['day_diff_pre'] == 0 and visit_count == 0 and not pd.isna(row['seatsys']):
                visit_count += 1
                group.loc[idx, f'bp_pre_MRA_visit_{visit_count}'] = row['seatsys']
                day_diff_pre_values.append(row['day_diff_pre'])

        # Calculate statistics for day_diff_pre
        if day_diff_pre_values:
            group['mean_day_diff_pre'] = np.mean(day_diff_pre_values)
            group['median_day_diff_pre'] = np.median(day_diff_pre_values)
            group['min_day_diff_pre'] = np.min(day_diff_pre_values)
            group['max_day_diff_pre'] = np.max(day_diff_pre_values)
        else:
            group['mean_day_diff_pre'] = np.nan
            group['median_day_diff_pre'] = np.nan
            group['min_day_diff_pre'] = np.nan
            group['max_day_diff_pre'] = np.nan

        return group

    # Apply the function to each patient group
    df = df.groupby('maskid').apply(process_patient)

    # Calculate the average of bp_pre_MRA across visits
    bp_pre_mra_columns = [f'bp_pre_MRA_visit_{i}' for i in range(1, max_visits + 1)]
    df['avg_bp_pre_MRA'] = df[bp_pre_mra_columns].mean(axis=1)

    return df

# Assuming you have your dataframe loaded as 'df'
# df = pd.read_csv('your_data.csv')

# Apply the function to your dataframe
df = calculate_bp_pre_mra(df)

# Display the results
print(df[['maskid', 'day_diff_pre', 'consistent_med', 'seatsys'] + 
        [f'bp_pre_MRA_visit_{i}' for i in range(1, 11)] + 
        ['avg_bp_pre_MRA', 'mean_day_diff_pre', 'median_day_diff_pre', 'min_day_diff_pre', 'max_day_diff_pre']])

# Save the results
df.to_csv('bp_pre_mra_results_test_9.1.csv', index=False)
print("Results saved to 'bp_pre_mra_results_test.csv'")






Footnote:
Inside the process_patient function, the list day_diff_pre_values is used to store the day_diff_pre values for valid visits. When a valid visit is recorded (i.e., when we set a value for bp_pre_mra_visit_X), we also append the corresponding day_diff_pre value to our list. After processing all rows for a patient, statistics such as mean, median, min, and max of the day_diff_pre values are calculated.


* back to STATA 16
import delimited "/Users/jiawei/Downloads/bp_pre_mra_9.3.csv", clear 

save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/preMRA_bpavg_frmpython9.3.dta"

sort maskid formdays
by maskid: egen previsit1BP = max(bp_pre_mra_visit_1)
by maskid: egen previsit2BP = max(bp_pre_mra_visit_2)
by maskid: egen previsit3BP = max(bp_pre_mra_visit_3)
by maskid: egen previsit4BP = max(bp_pre_mra_visit_4)
egen row_mean = rowmean(previsit1BP previsit2BP previsit3BP previsit4BP) 
rename row_mean meanSBPpreMRA
rename meanSBPpreMRA new_first_sbp_avg


save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/preMRA_bpavg_frmpython9.3.dta", replace

* With the above I had transferred python pre-mra averaged SBP 
* Combine this with the FULL cohort... 

use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_mra_9.3 .dta"
drop _merge

* merge with formdays as part of the criteria as well because the maskid is not unique, but the maskid+formdays combo is unique 
merge m:m maskid formdays using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/preMRA_bpavg_frmpython9.3.dta"
sort maskid formdays

Output: 



. distinct maskid if _merge ==3


(this 4451 number is different from prior, filter out anyone who is not on thiazide- I need that prior obs for baseline BP calculation before 
they change their status to thiazide-users, to get systolic BP baseline for every one on thiazide and apply the filters afterwards)

* fill up the entire column with the new first SBP avg 
egen new_first_sbp_avg_filled = min(new_first_sbp_avg) , by (maskid)

. distinct maskid if MRA ==1 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |      19989       2056

. 
. distinct maskid if MRA ==1 & new_first_sbp_avg_filled !=.

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |      19899       2029



* Handling Missing Baseline SBP:

* Missing SBP at baseline occurs when first_mra_daysstart falls between two visits. In such cases, the prior visit may have a missing seatsys or may have occurred more than 60 days before MRA initiation. Additionally, if in the visit where MRA is first started, formdays is greater than first_mra_daysstart, the SBP recorded reflects a post-MRA initiation visit. Since this SBP does not represent the baseline before MRA initiation, it is excluded from the analysis. This sequence can result in gaps in baseline SBP data for some patients.

* Steps to Identify Missing SBP for MRA:
* Identify maskid Where MRA == 1 and new_first_sbp_avg_filled went Missing


gen is_missing_sbp = missing(new_first_sbp_avg_filled)
List maskid with MRA == 1 and Missing new_first_sbp_avg_filled:


list maskid if first_mra_occurrence == 1 & is_missing_sbp == 1



* Check if these individuals have seatsys not missing when mra_occurrence == 1

. list maskid seatsys if first_mra_occurrence == 1 & is_missing_sbp == 1 & !missing(seatsys)

  




* create a subset of data to store these maskid with missing baseline SBP 

* Create flags for the conditions
gen is_missing_sbp = missing(new_first_sbp_avg_filled)

* Identify the maskid that meet the condition
gen condition_met = (first_mra_occurrence == 1 & is_missing_sbp == 1 )

* Create a flag for maskid that meet the condition
bysort maskid: egen maskid_meets_condition = max(condition_met)

* Generate the subset and save it as a new dataset
preserve
keep if maskid_meets_condition == 1

* Keep only the required variables
keep maskid formdays first_mra_daysstart first_mra_formdays med_category seatsys

* Save the subset to a new dataset
save subset_MRA_ missing_baselineSBP_maskid.dta, replace

* Restore the original dataset
restore

* I stored the data under "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/analysis/data/subset_MRA_ missing_baselineSBP_maskid.dta")"



* The mean days SBP was obtained prior to mra initiation

		
                      mean_day_diff_pre
-------------------------------------------------------------
      Percentiles      Smallest
 1%            0              0
 5%            0              0
10%            0              0       Obs               2,970
25%            0              0       Sum of Wgt.       2,970

50%         13.5                      Mean           11.23998
                        Largest       Std. Dev.       11.0202
75%           18             58
90%           27             58       Variance       121.4448
95%           29             59       Skewness        .650187
99%           41             60       Kurtosis       2.993742


* Post-MRA Initiation SBP Calculation:
* Remove the Pre-MRA Consistent Medication Data:

drop consistent_med




* Identify SBP Within 90 Days Post-MRA Initiation:


gen diff = formdays - min_mra_daystart if mra == 1
keep if diff != . & diff < 91
keep if diff >= 0 & diff != .

sort maskid formdays

* Check for Consistent Medication Category:
* Generate a variable consistent_med to check if the medication category remains unchanged.

by maskid: gen consistent_med = (med_category == med_category[1])


* The medication category at the time MRA was first initiated serves as the reference for determining consistent_med.
* If consistent_med turns to zero, it indicates a change in the medication category from the prior visit.
* In such cases, the SBP value in the row where consistent_med becomes zero will still be used because the impact of the medication change will be reflected in the subsequent SBP measurement, not the current one.

* Filter Observations to Keep Only Those Within 90 Days Post-MRA Initiation:

After applying the filters, the number of individuals reduces from 2056 to 2007.
Python Loop for Delta SBP Calculation:

2007 individuals are entered into the Python loop for delta SBP calculation.





* Save the dataset
save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_w_preMRASBP_prepforpython9.3.dta"

* Browse and export the data
browse maskid formdays new_first_sbp_avg_filled min_mra_daystart diff seatsys med_category 

export delimited maskid formdays new_first_sbp_avg_filled min_mra_daystart diff seatsys med_category consistent_med using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/export_postmra_bp_to_python_9.3", replace




* enter python 

import numpy as np
import pandas as pd

# Sort the dataframe by maskid and formdays
df = df.sort_values(['maskid', 'formdays'])

# Initialize new columns for results
df['bp_diff'] = np.nan
df['days_since_MRA'] = np.nan

# Initialize columns for visit-specific bp_diff
for i in range(1, 6):
    df[f'bp_diff_visit_{i}'] = np.nan

# Initialize new columns for diff duration statistics
df['mean_diff_duration'] = np.nan
df['median_diff_duration'] = np.nan
df['min_diff_duration'] = np.nan
df['max_diff_duration'] = np.nan

# Group the dataframe by maskid
for maskid, group in df.groupby('maskid'):
    group = group.copy()  # Create a copy to avoid SettingWithCopyWarning
    
    # Check if MRA_daystart is NaN for all rows in this group
    if group['min_MRA_daystart'].isna().all():
        continue
    
    # Find the first non-NaN MRA_daystart
    min_MRA_daystart = group['min_MRA_daystart'].dropna().iloc[0]
    
    # Calculate days since MRA start
    group['days_since_MRA'] = group['formdays'] - min_MRA_daystart
    
    # Filter rows that are at least 30 days after MRA start
    eligible_rows = group[group['days_since_MRA'] >= 30]
    
    if eligible_rows.empty:
        continue  # Skip if no eligible rows
    
    visit_count = 0
    last_valid_seatsys = None
    diff_durations = []  # List to store diff durations for statistics
    
    for idx, row in eligible_rows.iterrows():
        if pd.isna(row['seatsys']) and last_valid_seatsys is not None:
            seatsys = last_valid_seatsys
        else:
            seatsys = row['seatsys']
            last_valid_seatsys = seatsys
        
        if pd.notna(seatsys):
            bp_diff = seatsys - row['new_first_sbp_avg_filled']
            if row['consistent_med'] == 1:
                visit_count += 1
                group.loc[idx, f'bp_diff_visit_{visit_count}'] = bp_diff
                group.loc[idx, 'bp_diff'] = bp_diff
                diff_durations.append(row['days_since_MRA'])
            elif row['consistent_med'] == 0:
                group.loc[idx, 'bp_diff'] = bp_diff
                diff_durations.append(row['days_since_MRA'])
                break  # Stop calculating bp_diff after consistent_med becomes 0
    
    # Calculate average bp_diff across all visits
    bp_diff_columns = [f'bp_diff_visit_{i}' for i in range(1, 6)]
    group['avg_bp_diff'] = group[bp_diff_columns].mean(axis=1)
    
    # Calculate statistics for diff durations
    if diff_durations:
        mean_diff_duration = np.mean(diff_durations)
        median_diff_duration = np.median(diff_durations)
        min_diff_duration = np.min(diff_durations)
        max_diff_duration = np.max(diff_durations)
        
        # Assign these values to all rows in the group
        group['mean_diff_duration'] = mean_diff_duration
        group['median_diff_duration'] = median_diff_duration
        group['min_diff_duration'] = min_diff_duration
        group['max_diff_duration'] = max_diff_duration
    
    # Update the original dataframe with the results
    df.update(group)

# Export to STATA
float_columns = df.select_dtypes(include=['float64']).columns
df[float_columns] = df[float_columns].astype('float32')
df.to_stata('post_MRA_BP_avg_file_9.3.dta', version=117, write_index=True)
print("Data exported successfully")
 


# Import to STATA
use "/Users/jiawei/Downloads/post_MRA_BP_avg_file_9.3.dta"
egen mean_bp_diff_mra = mean(bp_diff), by(maskid)

* RENAME bp_diff, there is another bp_diff in the thiazide cohort
rename bp_diff mra_bp_diff 


* an excerpt of the dataset




Footnote:

* Each maskid will have a single mean_diff, representing the average of the formdays used to calculate the change in blood pressure 
For example, if BP measurements were taken on days 36 and 58, the average formdays would be 47. This represents the mean duration of formdays for calculating the delta SBP 

* Since each maskid has one mean_diff duration, I will take only one observation per maskid. This ensures that when I calculate the average mean_diff duration, the denominator reflects unique individuals rather than all available observations.


sort maskid formdays
by maskid: gen first_obs = (_n == 1)

bysort first_ob: summarize mean_diff_duration, detail


			
			. distinct maskid if bp_diff !=.
			
			        |        Observations
			        |      total   distinct
			--------+----------------------
			 maskid |       2459       1593



* A total of 1593 out of 2007 BP deltas were calculated, with a mean formdays of 55, which is excellent! 
The range of formdays spans from 30 to 90, in line with our criteria. 
* the number went down from 2007 to 1593 secondarily to the filters in Python 
1) BP must be >30 days post thiazide initiation 
2) the medication list is constant across the visits 


save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/from python delta BP MRA 9.3.dta"


* now merge the dataset with masterdata

use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_mra_9.3.dta"
drop _merge
merge m:m maskid formdays using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/from python delta BP MRA 9.3.dta"
drop _merge 

			
			    Result                           # of obs.
			    -----------------------------------------
			    not matched                        74,991
			        from master                    74,991  (_merge==1)
			        from using                          0  (_merge==2)
			
			    matched                             5,052  (_merge==3)
			    -----------------------------------------
			


Output: 

	                
			. distinct maskid if mean_bp_diff !=. 
			
			        |        Observations
			        |      total   distinct
			--------+----------------------
			 maskid |       4406       1593
			
			. distinct maskid if mean_bp_diff !=. & thiazide ==1
			
			        |        Observations
			        |      total   distinct
			--------+----------------------
			 maskid |       4406       1593





* only 1593 available for delta BP 

			
			. summarize mean_bp_diff, detail, if thiazide ==1
			
			                    mean_bp_diff_thiazide
			-------------------------------------------------------------
			      Percentiles      Smallest
			 1%          -54            -95
			 5%          -41            -95
			10%          -35          -74.5       Obs               4,406
			25%    -23.66667          -74.5       Sum of Wgt.       4,406
			
			50%       -13.75                      Mean          -14.51581
			                        Largest       Std. Dev.      15.53865
			75%         -4.5             35
			90%            4             70       Variance       241.4497
			95%            9             70       Skewness      -.1840778
			99%         21.5             70       Kurtosis       4.228885
			
			. summarize mean_bp_diff, detail
			
			                    mean_bp_diff_thiazide
			-------------------------------------------------------------
			      Percentiles      Smallest
			 1%          -54            -95
			 5%          -41            -95
			10%          -35          -74.5       Obs               4,406
			25%    -23.66667          -74.5       Sum of Wgt.       4,406
			
			50%       -13.75                      Mean          -14.51581
			                        Largest       Std. Dev.      15.53865
			75%         -4.5             35
			90%            4             70       Variance       241.4497
			95%            9             70       Skewness      -.1840778
			99%         21.5             70       Kurtosis       4.228885

* ? The mean SBP is averaged across observations or individuals?
* to solve this assign 1 number to each maskid and they all have only 1 observation with 1 delta BSP 
* carry forward the mean_bp_diff_mra for each maskid 

sort maskid formdays 
egen mean_bp_diff_mra_filled = min(mean_bp_diff_mra) , by (maskid)


sort maskid formdays
by maskid: gen first_obs_fordeltaBP = (_n == 1)

. summarize mean_bp_diff_mra_filled, detail, if first_obs_fordeltaBP ==1

		
* okay they are essentially the same
* note that the duration of days post mra is 55.6 day - which is pretty good



* create the FINAL mra cohort
gen mra_cohort = .
replace mra_cohort = 1 if mean_bp_diff_mra_filled !=. 

. distinct maskid if mra_cohort ==1 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |      28359       1593


