
STATA16 code: 

use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/analysis/data/bp_med_log_v2.dta", clear

* drop duplicated 
sort maskid formdays
quietly by maskid formdays:  gen dup = cond(_N==1,0,_n)
tab dup
drop if dup == 2 
drop if dup == 3

Output:

          . tab dup
          
                  dup |      Freq.     Percent        Cum.
          ------------+-----------------------------------
                    0 |    193,129       99.84       99.84
                    1 |        154        0.08       99.92
                    2 |        154        0.08      100.00
                    3 |          3        0.00      100.00
          ------------+-----------------------------------
                Total |    193,440      100.00
          
          . drop if dup == 2 
          (154 observations deleted)
          
          . drop if dup == 3
          (3 observations deleted)


drop if visitcode == "CLO"

          . drop if visitcode == "CLO"
          (7,866 observations deleted)
          
          . distinct maskid 
          
                  |        Observations
                  |      total   distinct
          --------+----------------------
           maskid |     185417       9344
          
          

// Define the list of medication names to search for
// Create a local macro with the list of medications
local medlist `""amiloride HCTZ" "amiloride/PHCTZ" "amiloride/HCTZ" "AMLORIDE/HCTZ" "atenolol chlorthalidone" "atenolol / chlorthalidone" "Atenolol /Chlorthalidone" "atenolol-chlorthalidone" "atenolol/chlorthalidone" "Atenolol/Chlorthalidone" "Atenolol/Chlorthalize" "atenolol/HCTZ" "azilsartan / chlorthalidone" "azilsartan/chlorthalidone" "azilsartan/chlothalidone" "benazepril/hctz" "benicar hct" "benicar/hctz" "diovan hct" "diovan hctz" "diovan/hct" "Diovan/HCTZ" "Diovan/Hct" "diovan/hctz" "Hydrochlorothiazide / Triamterene" "hydrochlorothiazide triamte" "hydrochlorothiazide triamterene" "hydrochlorothiazide/lisinopril" "hydrochlorothiazide/triamterene" "Hydrochlorothiazide/lisinopril" "Hydrochlorothiazide/lisinoprol" "hct triamterene" "hct z/triamterene" "HCTZ 25/TRIAMTERENE 37.5MG TAB" "hctz / lisinopril" "HCTZ /Triamterene" "hctz / lisonopril" "hctz 12.5/ lisonopril" "hctz 50/triam 75" "HCTZ-Aldactone" "hctz/chlorthalidine" "HCTZ/Lisinopril" "hctz/lisinopril" "hctz/olemesarten" "hctz/quinapril" "hctz/ triamterene" "HCTZ/ LISINOPRIL" "hctz/triamterene" "HCTZ/TRIAMTERENE" "HCTZ/Triamterene" "hyzaar" "hyzaar/Hctz" "lisinopril hct" "Lisinopril / HCTZ" "Lisinopril /HCTZ" "lisinopril-hctz" "lisinopril/ hydrochlorothiaz" "Lisinopril-HCT" "lisinopril/HCTZ" "Lisinopril-HCTZ" "lisinopril hydrochlorothiaz" "Lisinopril-Hydrochlorothiazide" "lisinopril hydrochlorothiazide" "lisinopril/hctz" "Lisinopril/HCTZ" "lisinoprilHCTZ" "losartan / hctz" "losartan/HCTZ" "losartan/hctz" "monopril hct" "moexipril / hctz" "spironolactone hct2" "spironolactone hctz" "spironolactone hydrochlorot" "spironolactone hydrochlorothiazide" "spironolactone-hctz" "spironolactone/HCTZ" "Triamterene HCTZ" "Triamterene Hydrochlorothiazide" "Triamterene hydrochlorothiaze" "Triamterene/ HCTZ" "Triamterene/HCTZ" "Triamterene/Hctz" "TRIAMETERENE/HCTZ" "TRIAMTERENE HCTZ" "TRIAMTERENE/HCTZ" "triam hctz" "triam/hctz" "triameterene" "triameterene/hydrochlorothiazide" "triamterene hctz" "triamterene / hctz" "triamterene hctz" "triamterene hydrochlorothia" "triamterene hydrochlorothiazide" "triamterene-hctz" "triamterene/ hctz" "triamterene/HCTZ" "triamterene/hctz" "triamterene/hydrochlorothia" "valsartan hctz" "valsartan/hctz" "ATENOLOL/CHLORTHALIDONE" "AZISARTAN/HCT" "Amiloride HCTZ" "Atenolol/HCTZ" "Azilsartan/chlothalidone" "Benazapril/HCTZ (PCP-prescribed)" "Benecor/HCTZ" "Benzapril/HCTZ" "Bisoprolol w/hctz (per her PCP)" "DIOVAN/ HCTZ" "DIOVAN HTC" "DIOVAN HCT" "Diovan HCT" "Diovan HCT (PCP prescribed)" "Diovan hct" "Diovan/hctz" "EDARBYCLOR/Chlorthalidone" "EDARBYCLOR" "Edarbyclor" "Enalapril/HCTZ" "Hydroclorothiazide/lisinopril" "Lisinopril HCTZ" "Losartan / HCTZ (PCP-prescribed, 1/2 )" "Losartan HCTZ" "Losartan potassium HCTZ" "Losartan/HCTZ" "Losartan/hctz" "McCardis HCTZ" "Micardis/HCTZ" "Spironolactone-HCTZ" "Triamterine/HCTZ" "Valsartan/HCTZ" "aldactazide" "amiloride & hctz" "amiloride / hctz" "amiloride /hctz" "amiloride hctz (5/50 mg tab (take 1)" "amiloride/hctz" "amoxipril/ HCTZ" "benazapril/hctz" "bisoprolol hctz" "enalapril hydrochlorothiazi" "hydrochlorothiazide / lisinopril" "isinopril hydrochlorothiaz" "lisinipril hctz" "lisinopril hctz" "lisinopril/hydrochlorothiazide" "maxzide" "maxide" "microzide (Hctz)" "olmesartan/hctz" "spironactone-hctz" "spironalactone/htct" "triamterene  hctz" "amiloride hctz" "HCTZ/triamterene" "HCTZ/lisinopril" "amiloride &" "amiloride & (5/50 mg.)   (take 1/2 tab)" "amiloride w/" "amiloride with" "amlodipine/hctz" "Amiloride w/" "lisinopril HCTZ" "amloride/hydrochloride and hydrochlorothiazide""'

forvalues i = 1/10 { 
    foreach med of local medlist {
        drop if medname`i' == "`med'"
    }
} 


Output: 
                     
          . distinct maskid 
          
                  |        Observations
                  |      total   distinct
          --------+----------------------
           maskid |     178135       9251


* Sort the data by maskid and formdays
sort maskid formdays

* Generate the thiazide column, thiazide use ==1 
gen thiazide = 0
forvalues i = 1/10 {
    replace thiazide = 1 if (strpos(lower(medname`i'), "hctz") > 0 | strpos(lower(medname`i'), "hct") > 0 | strpos(lower(medname`i'), "hydro") > 0 | strpos(lower(medname`i'), "chlorth") > 0 | strpos(lower(medname`i'), "chloro") > 0 | strpos(lower(medname`i'), "indapa") > 0 |strpos(lower(medname`i'), "metolaz") > 0 |strpos(lower(medname`i'), "diurel") > 0 | strpos(lower(medname`i'), "azide") > 0 | strpos(lower(medname`i'), "lidone") > 0)
}

Output: 

            . distinct maskid if thiazide ==1 
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      88353       6675
            

* Generate a flag for each medname column for thiazide 
forvalues i = 1/10 {
    gen flag_mra`i' = strpos(lower(medname`i'), "hctz") > 0 | strpos(lower(medname`i'), "hct") > 0 | strpos(lower(medname`i'), "hydro") > 0 | strpos(lower(medname`i'), "chlorth") > 0 | strpos(lower(medname`i'), "chloro") > 0 | strpos(lower(medname`i'), "indapa") > 0 |strpos(lower(medname`i'), "metolaz") > 0 |strpos(lower(medname`i'), "diurel") > 0 | strpos(lower(medname`i'), "azide") > 0 | strpos(lower(medname`i'), "lidone") > 0
}

* Create variables to store the first occurrence
gen first_thiazide_formdays = .
gen first_thiazide_daysstart = .
gen first_thiazide_medname = ""
gen multiple_thiazide_starts = 0

* Sort and create thiazide order variable
sort maskid formdays
by maskid: gen thiazide_order = sum(flag_thiazide1 + flag_thiazide2 + flag_thiazide3 + flag_thiazide4 + flag_thiazide5 + flag_thiazide6 + flag_thiazide7 + flag_thiazide8 + flag_thiazide9 + flag_thiazide10)

* Find the first occurrence of thiazide
gen any_thiazide = (flag_thiazide1 + flag_thiazide2 + flag_thiazide3 + flag_thiazide4 + flag_thiazide5 + flag_thiazide6 + flag_thiazide7 + flag_thiazide8 + flag_thiazide9 + flag_thiazide10) > 0
by maskid (formdays), sort: replace first_thiazide_formdays = formdays if any_thiazide & first_thiazide_formdays == .

* Identify the specific thiazide and its daysstart
forvalues j = 1/10 {
    by maskid (formdays): replace first_thiazide_daysstart = daysstart`j' if flag_thiazide`j' & formdays == first_thiazide_formdays & first_thiazide_daysstart == .
    by maskid (formdays): replace first_thiazide_medname = medname`j' if flag_thiazide`j' & formdays == first_thiazide_formdays & first_thiazide_medname == ""
}

* Check for multiple thiazide starts
by maskid (formdays): replace multiple_thiazide_starts = 1 if any_thiazide & formdays > first_thiazide_formdays & first_thiazide_formdays != .


* explanation: 
* The conditions:

any_mra: This checks if there's an thiazide medication present in this row.
formdays > first_thiazide_formdays: This checks if the current formdays is greater than the formdays of the first thiazide start. This indicates a later date.
first_thiazide_formdays != .: This ensures that we've actually found a first thiazide start (it's not missing).
For each patient, going through their data chronologically, if we find an thiazide medication on a day that's later than the day we first saw a thiazide medication, mark this patient as having multiple thiazide starts. This helps identify patients who may have stopped and restarted thiazide medications, or switched between different medications. The multiple_thiazide_starts flag will be set to 1 for these patients, indicating that they had more than one distinct period of thiazide medication use.


* Check for concurrent medication starts
* Ensure the data is sorted by maskid and formdays
sort maskid formdays

* Identify the first occurrence of Thiazide for each maskid
by maskid: gen first_thiazide_occurrence = _n == 1 if first_thiazide_daysstart != .

* Initialize concurrent_start variable
gen concurrent_start = 0

* Check for concurrent medication starts only for the first Thiazide occurrence
forvalues j = 1/10 {
    replace concurrent_start = 1 if first_thiazide_occurrence == 1 & daysstart`j' == first_thiazide_daysstart & !flag_thiazide`j' & first_thiazide_daysstart != .
}

* Create a flag for cases where Thiazide started without concurrent meds
gen thiazide_solo_start = (first_thiazide_occurrence == 1 & first_thiazide_daysstart != . & concurrent_start == 0)

* Create a flag for cases where MRA started without concurrent meds
gen mra_solo_start = (first_mra_daysstart != . & concurrent_start == 0)

* Explanation:
* It compares the Thiazide daysstart with the other daysstart1 to daysstart10 of medname1 to medname10 that are NOT Thiazides, and marks concurrent_start as 1 if there's another medication that shares the same daysstart with the Thiazide.




Output: 

            . distinct maskid if thiazide_solo_start ==1
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      65062       5783

* Keep the 1st observation of thiazide being started 
sort maskid formdays
bys maskid: egen min_thiazide_daystart = min(first_thiazide_daysstart)

* Remove patients who are on thiazide at baseline
distinct maskid if thiazide == 1 & min_thiazide_daystart < 0
distinct maskid if thiazide == 1 & min_thiazide_daystart >= 0

Output: 
            . distinct maskid if thiazide == 1 & min_thiazide_daystart < 0
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      38986       2690
            
            . distinct maskid if thiazide == 1 & min_thiazide_daystart >= 0
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      49367       3985
            

               

drop if min_thiazide_daystart < 0

Output: 
          . distinct maskid 
          
                  |        Observations
                  |      total   distinct
          --------+----------------------
           maskid |     125454       6561
          
          . distinct maskid if thiazide_solo_start ==1
          
                  |        Observations
                  |      total   distinct
          --------+----------------------
           maskid |      38095       3531
          
          . distinct maskid if thiazide==1
          
                  |        Observations
                  |      total   distinct
          --------+----------------------
           maskid |      49367       3985



* generate a cumulative count of how many times thiazide treatment starts for each patient
* counts the number of times thiazide switches from 0 to 1 within each maskid group
* thiazide_occurrence will be a cumulative count of the occurrences where:
    thiazide  changes from 0 to 1, or
    thiazide  is 1 at the start for the maskid, or formdays is 0 and thiazide is 1. (because there is no prior to compare if started on formdays 0)
    Because thiazide use at baseline is already removed, if thiazide  use daystart = formdays 0 

sort maskid formdays
by maskid: gen thiazide_occurrence = sum(thiazide == 1 & (thiazide[_n-1] == 0 | _n == 1 | formdays == 0))

* Generate a thiazide cohort
gen cohort = .
replace cohort = 1 if thiazide_occurrence == 1 & thiazide_solo_start == 1


Output: 
            . distinct maskid if cohort ==1
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      33156       3397


* To know the previous visit before thiazide turns 1
gen prior_onThiazide = .
by maskid: replace prior_onThiazide = formdays[_n-1] if thiazide == 1 & (thiazide[_n-1] == 0 | _n == 1) & thiazide_occurrence == 1

* This subsequent code ensures that only the 1st occurrence is used
replace prior_onThiazide = . if thiazide_occurrence >= 2 & prior_onThiazide != .


* Merge with BP data 
merge m:m maskid formdays using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/analysis/data/allbp_intensive+standard.dta"

* Sort data by maskid and formdays
sort maskid formdays  

* Generate and fill up the entire column for each thiazide occurrence
* Generate variables for the first and second occurrences of thiazide
* The thiazide order has the num of occurrence as well but it does not carry forward

by maskid: gen first_onThiazide = formdays if thiazide == 1 & sum(thiazide) == 1
by maskid: gen second_onThiazide = formdays if thiazide == 1 & sum(thiazide) == 2

* Carry forward non-missing values in the column 'prior_onThiazide'
bysort maskid (formdays): gen prior_onThiazide_filled = prior_onThiazide if prior_onThiazide != .
bysort maskid (formdays): replace prior_onThiazide_filled = prior_onThiazide_filled[_n-1] if missing(prior_onThiazide_filled)

* Include the first row as well
by maskid: replace prior_onThiazide = prior_onThiazide[_n+1] if missing(prior_onThiazide) & !missing(prior_onThiazide[_n+1])

* Sort data again by maskid and formdays
sort maskid formdays

* Fill in the first and second occurrences of thiazide
by maskid: egen first_onThiazide_filled = max(first_onThiazide)
by maskid: egen second_onThiazide_filled = max(second_onThiazide)

* Generate and fill in the third and fourth occurrences of thiazide
by maskid: gen third_onThiazide = formdays if thiazide == 1 & sum(thiazide) == 3
by maskid: egen third_onThiazide_filled = max(third_onThiazide)
by maskid: gen fourth_onThiazide = formdays if thiazide == 1 & sum(thiazide) == 4
by maskid: egen fourth_onThiazide_filled = max(fourth_onThiazide)


* medication list
sort maskid formdays
gen med_oxin = 0
gen med_triam = 0
gen med_olol = 0
gen med_ipine_azem = 0
gen med_mra = 0
gen med_fur_bum_tors = 0
gen med_hydral_azine = 0
gen med_pril_artan = 0
gen med_idine_clon = 0
gen med_minoxi = 0 
gen med_guanfacine = 0 

* Check each medname variable for the specified patterns
forvalues i = 1/10 {
    replace med_oxin = 1 if regexm(lower(medname`i'), "(cardu|doxa|osin|oxin|hytrin|tera|tamsu|alfu)")
	replace med_triam = 0.0005 if regexm(lower(medname`i'), "(triam|amil)")
    replace med_olol = 2 if regexm(lower(medname`i'), "(olol|metop|coreg|carv|lopre|topr|propa|nebi|nado|atenelol)")
    replace med_ipine_azem = 5 if regexm(lower(medname`i'), "(ipine|azem|norv|vera|nife|proca|nicar|nefe|caduet)")
	replace med_minoxi = 10000 if regexm(lower(medname`i'), "(mino|xidil)")
	replace med_guanfacine = 0.01 if regexm(lower(medname`i'), "(guan)")
    replace med_mra = 9 if regexm(lower(medname`i'), "(spir|eple|aldac|inspra)")
    replace med_fur_bum_tors = 13 if regexm(lower(medname`i'), "(fur|bum|tors|inda|etha|demadex)")
    replace med_hydral_azine = 0.5 if regexm(lower(medname`i'), "(hydral|azine)")
    replace med_pril_artan = 1000 if regexm(lower(medname`i'), "(pril|artan|benic|vals|olme|edarbi|diovan|azil|trando|micardis|atacand)")
    replace med_idine_clon = 100 if regexm(lower(medname`i'), "(idine|clon|cata)")
}
* Sum all medication categories into a single variable
gen med_category = med_oxin + med_olol + med_ipine_azem + med_mra + med_fur_bum_tors + med_hydral_azine + med_pril_artan + med_idine_clon + med_minoxi + med_triam + med_guanfacine 

*this works for combination meds as well- for example, atenolol, amlodipine/benazapril, will sum up to 1007 ( 1000 + 5 + 2)

* Label the new variable
label variable med_category "Sum of medication categories"

* Clean up intermediate variables
drop med_oxin med_olol med_ipine_azem med_mra med_fur_bum_tors med_hydral_azine med_pril_artan med_idine_clon med_minoxi  med_triam med_guanfacine 




sort maskid formdays 
 
* Get med_category for first and second thiazide visits
by maskid: gen prior_med_category = med_category if formdays == prior_onThiazide

* Because prior_onThiazide is one row below
by maskid: replace prior_med_category = med_category if formdays == prior_onThiazide_filled

* Generate column to store "med_category" according to visits
by maskid: gen first_med_category = med_category if formdays == first_onThiazide
by maskid: gen second_med_category = med_category if formdays == second_onThiazide
by maskid: gen third_med_category = med_category if formdays == third_onThiazide
by maskid: gen fourth_med_category = med_category if formdays == fourth_onThiazide

* Fill these values for all rows within each maskid
by maskid: egen prior_med_category_filled = max(prior_med_category)
by maskid: egen first_med_category_filled = max(first_med_category)
by maskid: egen second_med_category_filled = max(second_med_category)
by maskid: egen third_med_category_filled = max(third_med_category)
by maskid: egen fourth_med_category_filled = max(fourth_med_category)

* Generate the difference in med_category between first and second visit - they should be equal 
gen med_category_diff_2_1 = second_med_category_filled - first_med_category_filled
gen med_category_diff_3_1 = third_med_category_filled - first_med_category_filled
gen med_category_diff_3_2 = third_med_category_filled - second_med_category_filled
gen med_category_diff_prior_1 = prior_med_category_filled - first_med_category_filled 
 
* Flag if med_category is unequal between visits
gen med_category_prior_1_unequal = (med_category_diff_prior_1 != 0 & med_category_diff_prior_1 !=.)
gen med_category_2_1_unequal = (med_category_diff_2_1 != 0 & med_category_diff_2_1 !=.)
gen med_category_3_1_unequal = (med_category_diff_3_1 != 0 & med_category_diff_3_1 !=. )
gen med_category_3_2_unequal = (med_category_diff_3_2 != 0 & med_category_diff_3_2 !=. ) 

* Label the new variables
label variable med_category_diff_2_1 "Difference in med_category between 1st and 2nd thiazide visits"
label variable med_category_2_1_unequal "Flag: 1 if med_category unequal between 1st and 2nd thiazide visits"

* Update cohort criteria
* Generate a thiazide cohort
gen cohort2 =.

* my cohort1 was = thiazide_occurrence == 1 and thiazide_solo_start == 1 without the med_category_prior_1_unequal == 0

replace cohort2 = 1 if thiazide == 1 & thiazide_occurrence == 1 & med_category_prior_1_unequal == 0 & thiazide_solo_start == 1 

Output: 

        . distinct maskid if cohort2 ==1
        
                |        Observations
                |      total   distinct
        --------+----------------------
         maskid |      31937       3251


* explanation: the 768 if from the criteria that no other meds share the SAME start day w thiazide. It does not exclude the meds that 
was started a couple of days before or after thiazide was started. The med_category list will reflect the changes of medications across visits, 
so it is a more robust way to ensure no other meds were started other than a thiazide. 

* Fill up the BP columns
* Generate variables for SBP at the time of thiazide occurrences
by maskid: gen first_SBP = seatsys if formdays == first_onThiazide_filled
by maskid: egen first_SBP_filled = max(first_SBP)
by maskid: gen second_SBP = seatsys if formdays == second_onThiazide_filled
by maskid: egen second_SBP_filled = max(second_SBP)
by maskid: gen third_SBP = seatsys if formdays == third_onThiazide_filled
by maskid: egen third_SBP_filled = max(third_SBP)
by maskid: gen fourth_SBP = seatsys if formdays == fourth_onThiazide_filled
by maskid: egen fourth_SBP_filled = max(fourth_SBP)



* Find out who has missing SBP at baseline

gen missing_SBP_baseline = .
replace missing_SBP_baseline = 1 if cohort ==1 & cohort !=. & first_SBP_filled !=.

Output: 

            . distinct maskid if missing_SBP_baseline ==1 & cohort2 ==1
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      31205       3160
            
            . distinct maskid if missing_SBP_baseline ==1 & cohort ==1
            
                    |        Observations
                    |      total   distinct
            --------+----------------------
             maskid |      32380       3297

               

* explanation: out of the total 3251 eligible subjects (cohort2 ==1), 3251-3297 has missing SBP 

* save as masterdata 
save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_thiazide_9.1.dta"


* Generate a subdata for calculation of average BP pre-MRA initiation 
use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_thiazide_9.1.dta"
sort maskid formdays

* Because the min_thiazide_daystart fills up the entire column, I therefore removed anyone who has a 
missing value meaning they have never been on a thiazide at anytime during the trial 

drop if min_thiazide_daystart ==.  

Output: 
                . distinct maskid if cohort2 ==1
                  
                          |        Observations
                          |      total   distinct
                  --------+----------------------
                   maskid |      31937       3251



gen day_diff_pre = min_thiazide_daystart - formdays

* The thiazide daystart should be greater than the formdays because I want to obtain the BP values in visits PRIOR to thiazide initiation
sort maskid formdays
drop if day_diff_pre < 0 & day_diff_pre != .

* Limit the prior visit to within 60 days
drop if day_diff_pre > 60

* Instead of sorting by formdays
* Sort by day_diff_pre so the first observation of the med_category, which is the day thiazide is started,
* can be used as a reference for prior visit med_category

sort maskid day_diff_pre
by maskid: gen consistent_med = (med_category == med_category[1])

* Browse data to export to Excel as CSV file
browse maskid formdays seatsys day_diff_pre consistent_med min_thiazide_daystart

export delimited maskid formdays seatsys day_diff_pre consistent_med min_thiazide_daystart using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/export_preThiazide_bp_to_python_9.1.csv", replace

save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/subset_masterdata_thiazide_9.1_for_preThiazide_SBP_python.dta"



* enter Python 
import numpy as np
import pandas as pd

if 'maskid' in df.index.names:
    df.reset_index(inplace=True)


# Sort the dataframe by maskid and formdays
df = df.sort_values(['maskid', 'formdays'])


def calculate_bp_pre_thiazide(df):
    # Sort the dataframe by maskid and day_diff_pre in descending order
    df = df.sort_values(['maskid', 'day_diff_pre'], ascending=[True, False])

    # Initialize columns for bp_pre_thiazide visits
    max_visits = 10  # Adjust this number based on your data
    for i in range(1, max_visits + 1):
        df[f'bp_pre_thiazide_visit_{i}'] = np.nan

    # Function to process each patient
    def process_patient(group):
        visit_count = 0
        record_seatsys = False
        day_diff_pre_values = []  # List to store day_diff_pre values for valid visits

        for idx, row in group.iterrows():
            if 0 <= row['day_diff_pre'] <= 60:
                if row['consistent_med'] == 1:
                    if not pd.isna(row['seatsys']):
                        visit_count += 1
                        group.loc[idx, f'bp_pre_thiazide_visit_{visit_count}'] = row['seatsys']
                        day_diff_pre_values.append(row['day_diff_pre'])
                        record_seatsys = True
                elif row['consistent_med'] == 0:
                    # Reset when consistent_med turns 0
                    record_seatsys = False
                    visit_count = 0
            if row['day_diff_pre'] == 0 and visit_count == 0 and not pd.isna(row['seatsys']):
                visit_count += 1
                group.loc[idx, f'bp_pre_thiazide_visit_{visit_count}'] = row['seatsys']
                day_diff_pre_values.append(row['day_diff_pre'])

        # Calculate statistics for day_diff_pre
        if day_diff_pre_values:
            group['mean_day_diff_pre'] = np.mean(day_diff_pre_values)
            group['median_day_diff_pre'] = np.median(day_diff_pre_values)
            group['min_day_diff_pre'] = np.min(day_diff_pre_values)
            group['max_day_diff_pre'] = np.max(day_diff_pre_values)
        else:
            group['mean_day_diff_pre'] = np.nan
            group['median_day_diff_pre'] = np.nan
            group['min_day_diff_pre'] = np.nan
            group['max_day_diff_pre'] = np.nan

        return group

    # Apply the function to each patient group
    df = df.groupby('maskid').apply(process_patient)

    # Calculate the average of bp_pre_thiazide across visits
    bp_pre_thiazide_columns = [f'bp_pre_thiazide_visit_{i}' for i in range(1, max_visits + 1)]
    df['avg_bp_pre_thiazide'] = df[bp_pre_thiazide_columns].mean(axis=1)

    return df

# Assuming you have your dataframe loaded as 'df'
# df = pd.read_csv('your_data.csv')

# Apply the function to your dataframe
df = calculate_bp_pre_thiazide(df)

# Display the results
print(df[['maskid', 'day_diff_pre', 'consistent_med', 'seatsys'] + 
        [f'bp_pre_thiazide_visit_{i}' for i in range(1, 11)] + 
        ['avg_bp_pre_thiazide', 'mean_day_diff_pre', 'median_day_diff_pre', 'min_day_diff_pre', 'max_day_diff_pre']])

# Save the results
df.to_csv('bp_pre_thiazide_results_test_9.1.csv', index=False)
print("Results saved to 'bp_pre_thiazide_results_test_9.1.csv'")


Footnote:
Inside the process_patient function, the list day_diff_pre_values is used to store the day_diff_pre values for valid visits. When a valid visit is recorded (i.e., when we set a value for bp_pre_thiazide_visit_X), we also append the corresponding day_diff_pre value to our list. After processing all rows for a patient, statistics such as mean, median, min, and max of the day_diff_pre values are calculated.


* back to STATA 16
import delimited "/Users/jiawei/Downloads/bp_pre_thiazide_results_test_9.1.csv", clear 

Output: (can export to excel for visibility) 

  maskid	formdays	seatsys	day_diff_pre	consistent_med	min_thiazide_daystart	bp_pre_thiazide_visit_1	bp_pre_thiazide_visit_2	bp_pre_thiazide_visit_3	bp_pre_thiazide_visit_4	mean_day_diff_pre	avg_bp_pre_thiazide
  S00007	0	145	2	1	2	145				2	145
  S00010	183	147	1	1	184	147				1	147
  S00046	0	126	0	1	0	126				0	126
  S00103	0	133	0	1	0	133				0	133
  S00109	0	137	36	1	36	137				20.5	137
  S00109	14		22	1	36					20.5	
  S00109	31	122	5	1	36		122			20.5	122
  S00128	0	125	0	1	0	125				0	125
  S00163	0	120	1	1	1	120				1	120
  S00193	32	137	60	1	92	137				30.5	137
  


save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/preThiazide_bpavg_frmpython9.1.dta"

sort maskid formdays
by maskid: egen previsit1BP = max(bp_pre_thiazide_visit_1)
by maskid: egen previsit2BP = max(bp_pre_thiazide_visit_2)
by maskid: egen previsit3BP = max(bp_pre_thiazide_visit_3)
by maskid: egen previsit4BP = max(bp_pre_thiazide_visit_4)
egen row_mean = rowmean(previsit1BP previsit2BP previsit3BP previsit4BP) 
rename row_mean meanSBPpreThiazide
rename meanSBPpreThiazide new_first_sbp_avg


save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/preThiazide_bpavg_frmpython9.1.dta", replace

* With the above I had transferred python pre-thiazide averaged SBP 
* Combine this with the FULL cohort... 

use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_thiazide_9.1.dta"
drop _merge

* merge with formdays as part of the criteria as well because the maskid is not unique, but the maskid+formdays combo is unique 
merge m:m maskid formdays using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/preThiazide_bpavg_frmpython9.1.dta"
sort maskid formdays

Output: 
            
                              Result                           # of obs.
                -----------------------------------------
                not matched                       187,463
                    from master                   187,463  (_merge==1)
                    from using                          0  (_merge==2)
            
                matched                             5,140  (_merge==3)
                -----------------------------------------
                . distinct maskid if _merge ==3
                
                        |        Observations
                        |      total   distinct
                --------+----------------------
                 maskid |       5140       3499


                (this 3499 number is different from prior, because I did not set cohort == 1 or cohort2 ==1 
                pre-MRA BP calculation. The purpose is to get systolic BP baseline for every one on      thiazide and apply the filters afterwards)

              . distinct maskid if cohort2 ==1 & first_SBP_filled !=.
              
                      |        Observations
                      |      total   distinct
              --------+----------------------
               maskid |      31205       3160


                (this number 3160 is the same as prior at line 372) 


* fill up the entire column with the new first SBP avg 
egen new_first_sbp_avg_filled = min(new_first_sbp_avg) , by (maskid)

                . distinct maskid if cohort2 ==1 & new_first_sbp_avg_filled !=.
                
                               
                      |        Observations
                      |      total   distinct
              --------+----------------------
               maskid |      28386       2879
              

by maskid: egen new_first_sbp_avg_filled_2 = max(new_first_sbp_avg) 

                . distinct maskid if cohort2 ==1 & new_first_sbp_avg_filled_2 !=.
                
                 
                      |        Observations
                      |      total   distinct
              --------+----------------------
               maskid |      28386       2879
              

* either egen min or max does not matter because the there is only ONE new_first_sbp_avg for each maskid 
* hence the number is the same, 2879 as shown above. 
* note that the number decreased from 634 to 2879 after the expanded criteria

* The mean days SBP was obtained prior to thiazide initiation

* The "consistent_med" from the pre-thiazide initiation BP data; now we want to calculate the post-thiazide initiation BP
drop consistent_med

* Now to get the SBP in 90 days post-thiazide
* Keep only observations within 90 days of first thiazide start or where first_thiazide_occurrence is 1
gen diff = formdays - min_thiazide_daystart if thiazide == 1
keep if diff != . & diff < 91
keep if diff >= 0

* Sort the data
sort maskid formdays 

* Check for consistent med_category again
by maskid: gen consistent_med = (med_category == med_category[1])

* Save the dataset
save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_w_prethiazideSBP_prepforpython9.1.dta"

* Browse and export the data
browse maskid formdays new_first_sbp_avg_filled min_thiazide_daystart diff seatsys med_category 

export delimited maskid formdays new_first_sbp_avg_filled min_thiazide_daystart diff seatsys med_category consistent_med using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/export_postthiazide_bp_to_python_9.1.csv", replace



* an excerpt of the data, can run in excel for visibility 
maskid	formdays	MRA	first_mra_formdays	min_MRA_daystart	med_category	cohort2	diff	consistent_med
S00087	119	1	119	119	1019	1	0	1
S00087	155	1	155	119	1008	1	36	0
S00087	189	1	189	119	1008	1	70	0
S00087	206	1	206	119	1008	1	87	0
S00193	54	1	54	33	1005		21	1
S00193	69	1	69	33	1005		36	1
S00193	91	1	91	33	1014		58	0

* note that the cohort2 comprised of restricted criteria- I had every one on MRA in this subset of data 
to get the max number of delta SBP, will apply filters afterwards
* med category of the first time MRA was started is used as the reference for consistent_med
* if consistent med turns zero, it marks a difference in med_category from the prior visit. 
* in this case, the SBP along the row which consistent_med turns zero will still be used because the medication changes effect
will be reflected in the NEXT SBP not the current one. 



* enter python 

import numpy as np
import pandas as pd

# Sort the dataframe by maskid and formdays
df = df.sort_values(['maskid', 'formdays'])

# Initialize new columns for results
df['bp_diff'] = np.nan
df['days_since_thiazide'] = np.nan

# Initialize columns for visit-specific bp_diff
for i in range(1, 6):
    df[f'bp_diff_visit_{i}'] = np.nan

# Initialize new columns for diff duration statistics
df['mean_diff_duration'] = np.nan
df['median_diff_duration'] = np.nan
df['min_diff_duration'] = np.nan
df['max_diff_duration'] = np.nan

# Group the dataframe by maskid
for maskid, group in df.groupby('maskid'):
    group = group.copy()  # Create a copy to avoid SettingWithCopyWarning
    
    # Check if thiazide_daystart is NaN for all rows in this group
    if group['min_thiazide_daystart'].isna().all():
        continue
    
    # Find the first non-NaN thiazide_daystart
    min_thiazide_daystart = group['min_thiazide_daystart'].dropna().iloc[0]
    
    # Calculate days since thiazide start
    group['days_since_thiazide'] = group['formdays'] - min_thiazide_daystart
    
    # Filter rows that are at least 30 days after thiazide start
    eligible_rows = group[group['days_since_thiazide'] >= 30]
    
    if eligible_rows.empty:
        continue  # Skip if no eligible rows
    
    visit_count = 0
    last_valid_seatsys = None
    diff_durations = []  # List to store diff durations for statistics
    
    for idx, row in eligible_rows.iterrows():
        if pd.isna(row['seatsys']) and last_valid_seatsys is not None:
            seatsys = last_valid_seatsys
        else:
            seatsys = row['seatsys']
            last_valid_seatsys = seatsys
        
        if pd.notna(seatsys):
            bp_diff = seatsys - row['new_first_sbp_avg_filled']
            if row['consistent_med'] == 1:
                visit_count += 1
                group.loc[idx, f'bp_diff_visit_{visit_count}'] = bp_diff
                group.loc[idx, 'bp_diff'] = bp_diff
                diff_durations.append(row['days_since_thiazide'])
            elif row['consistent_med'] == 0:
                group.loc[idx, 'bp_diff'] = bp_diff
                diff_durations.append(row['days_since_thiazide'])
                break  # Stop calculating bp_diff after consistent_med becomes 0
    
    # Calculate average bp_diff across all visits
    bp_diff_columns = [f'bp_diff_visit_{i}' for i in range(1, 6)]
    group['avg_bp_diff'] = group[bp_diff_columns].mean(axis=1)
    
    # Calculate statistics for diff durations
    if diff_durations:
        mean_diff_duration = np.mean(diff_durations)
        median_diff_duration = np.median(diff_durations)
        min_diff_duration = np.min(diff_durations)
        max_diff_duration = np.max(diff_durations)
        
        # Assign these values to all rows in the group
        group['mean_diff_duration'] = mean_diff_duration
        group['median_diff_duration'] = median_diff_duration
        group['min_diff_duration'] = min_diff_duration
        group['max_diff_duration'] = max_diff_duration
    
    # Update the original dataframe with the results
    df.update(group)

# Export to STATA
float_columns = df.select_dtypes(include=['float64']).columns
df[float_columns] = df[float_columns].astype('float32')
df.to_stata('post_thiazide_BP_avg_file_9.1.dta', version=117, write_index=True)
print("Data exported successfully")

# Import to STATA
use "/Users/jiawei/Downloads/post_thiazide_BP_avg_file_9.1.dta"
egen mean_bp_diff = mean(bp_diff), by(maskid)


* an excerpt of the dataset
        index	maskid	formdays	new_first_sbp_avg_filled	min_MRA_daystart	diff	seatsys	med_category	consistent_med	bp_diff	days_since_MRA	bp_diff_visit_1	bp_diff_visit_2	mean_diff_duration	mean_bp_diff
        0	S00087	119	159.6667	119	0	148	1019	1		0			36	-2.666672
        1	S00087	155	159.6667	119	36	157	1008	0	-2.666672	36			36	-2.666672
        2	S00087	189	159.6667	119	70	129	1008	0		70			36	-2.666672
        3	S00087	206	159.6667	119	87	101	1008	0		87			36	-2.666672
        4	S00193	54	142	33	21	145	1005	1		21			47	-21
        5	S00193	69	142	33	36	111	1005	1	-31	36	-31		47	-21
        6	S00193	91	142	33	58	131	1014	0	-11	58			47	-21
        7	S001E5	1079	127.5	1047	32	118	1017	1	-9.5	32	-9.5		57	-8.5
        8	S001E5	1129	127.5	1047	82	120	1017	1	-7.5	82		-7.5	57	-8.5
        9	S00248	185	129	185	0	129	1015	1		0			66	-13
        10	S00248	209	129	185	24	127	1015	1		24			66	-13


*footnote: each maskid will have ONE mean_diff which means the mean of the formdays used to calculate delta BP 
* for example, day 36 and 58 is used to calculate BP, it is averaged as 47

* the mean duration of formdays for SBP delta calculation 
* since each maskid have 1 mean diff duration, I will only take one observation from each maskid so when I average the mean diff duration, 
the denominator is comprised of unique individuals rather than all the available observations

sort maskid formdays
by maskid: gen first_obs = (_n == 1)

bysort first_ob: summarize mean_diff_duration, detail
                    -> first_obs = 1
                    
                                         mean_diff_duration
                    -------------------------------------------------------------
                          Percentiles      Smallest
                     1%           30             30
                     5%           33             30
                    10%           35             30       Obs                 648
                    25%           46             30       Sum of Wgt.         648
                    
                    50%           56                      Mean           56.74331
                                            Largest       Std. Dev.      15.26855
                    75%     66.83333             90
                    90%           78             90       Variance       233.1287
                    95%           84             90       Skewness        .249826
                    99%           90             90       Kurtosis        2.38899

* total of 648 BP delta calculated, the mean formdays for BP calculation is 56 which is pretty good!.... the smallest being 30 as reflected 
by our criterias.
* please note that this calculation is for every one on MRA, has yet to apply the filters for cohort 1 or cohort 2. 

save "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/from python delta BP 9.1.dta"


* now merge the dataset with masterdata

use "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/masterdata_MRA_9.1.dta"
drop _merge
merge m:m maskid formdays using "/Users/jiawei/Library/CloudStorage/Box-Box/JiaWeiTan Project folder (from Maria)/from python delta BP 9.1.dta"
drop _merge 


                Result                           # of obs.
                -----------------------------------------
                not matched                       193,643
                    from master                   193,643  (_merge==1)
                    from using                          0  (_merge==2)
            
                matched                             2,024  (_merge==3)
                -----------------------------------------

Output: 
                . distinct maskid if cohort2 ==1
                
                        |        Observations
                        |      total   distinct
                --------+----------------------
                 maskid |       6142        681
                
                . distinct maskid if cohort2 ==1 & mean_bp_diff !=. 
                
                        |        Observations
                        |      total   distinct
                --------+----------------------
                 maskid |       1019        425


                    . summarize mean_diff_duration, detail, if cohort2 ==1
                    
                                         mean_diff_duration
                    -------------------------------------------------------------
                          Percentiles      Smallest
                     1%           30             30
                     5%           34             30
                    10%           35             30       Obs               1,037
                    25%           47             30       Sum of Wgt.       1,037
                    
                    50%           57                      Mean           57.20958
                                            Largest       Std. Dev.      14.67629
                    75%           67             90
                    90%           77             90       Variance       215.3935
                    95%           84             90       Skewness       .1866568
                    99%           90             90       Kurtosis       2.452496



. summarize mean_diff_duration, detail, if cohort2 ==1

                     mean_diff_duration
-------------------------------------------------------------
      Percentiles      Smallest
 1%           30             30
 5%           34             30
10%           35             30       Obs               1,037
25%           47             30       Sum of Wgt.       1,037

50%           57                      Mean           57.20958
                        Largest       Std. Dev.      14.67629
75%           67             90
90%           77             90       Variance       215.3935
95%           84             90       Skewness       .1866568
99%           90             90       Kurtosis       2.452496

. summarize mean_bp_diff, detail, if cohort2 ==1

                        mean_bp_diff
-------------------------------------------------------------
      Percentiles      Smallest
 1%          -58            -74
 5%          -37            -61
10%          -30            -61       Obs               1,019
25%        -20.5            -61       Sum of Wgt.       1,019

50%          -11                      Mean          -11.60983
                        Largest       Std. Dev.      15.63657
75%           -2             31
90%            7             37       Variance       244.5022
95%           14             37       Skewness      -.2219578
99%         28.5             37       Kurtosis       3.954523


. distinct maskid if cohort2 ==1 & mean_bp_diff !=. 

        |        Observations
        |      total   distinct
--------+----------------------
 maskid |       1019        425


not sure why the mean_bp_diff and mean_bp_duration is different. 
